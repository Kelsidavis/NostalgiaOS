//! Syslog Client
//!
//! RFC 5424 - The Syslog Protocol
//! RFC 3164 - BSD Syslog Protocol (legacy)
//! Send log messages to remote syslog servers.

extern crate alloc;

use alloc::vec::Vec;
use core::sync::atomic::{AtomicU32, AtomicBool, Ordering};
use super::udp;
use super::ip::Ipv4Address;
use crate::ke::SpinLock;

/// Syslog UDP port
pub const SYSLOG_PORT: u16 = 514;

/// Maximum message size (RFC 3164)
pub const MAX_MESSAGE_SIZE: usize = 1024;

/// Syslog facility codes
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum Facility {
    /// Kernel messages
    Kern = 0,
    /// User-level messages
    User = 1,
    /// Mail system
    Mail = 2,
    /// System daemons
    Daemon = 3,
    /// Security/authorization messages
    Auth = 4,
    /// Messages generated by syslogd
    Syslog = 5,
    /// Line printer subsystem
    Lpr = 6,
    /// Network news subsystem
    News = 7,
    /// UUCP subsystem
    Uucp = 8,
    /// Clock daemon
    Cron = 9,
    /// Security/authorization messages (private)
    AuthPriv = 10,
    /// FTP daemon
    Ftp = 11,
    /// NTP subsystem
    Ntp = 12,
    /// Log audit
    Audit = 13,
    /// Log alert
    Alert = 14,
    /// Clock daemon (note 2)
    Clock = 15,
    /// Local use 0
    Local0 = 16,
    /// Local use 1
    Local1 = 17,
    /// Local use 2
    Local2 = 18,
    /// Local use 3
    Local3 = 19,
    /// Local use 4
    Local4 = 20,
    /// Local use 5
    Local5 = 21,
    /// Local use 6
    Local6 = 22,
    /// Local use 7
    Local7 = 23,
}

/// Syslog severity levels
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
#[repr(u8)]
pub enum Severity {
    /// System is unusable
    Emergency = 0,
    /// Action must be taken immediately
    Alert = 1,
    /// Critical conditions
    Critical = 2,
    /// Error conditions
    Error = 3,
    /// Warning conditions
    Warning = 4,
    /// Normal but significant condition
    Notice = 5,
    /// Informational messages
    Info = 6,
    /// Debug-level messages
    Debug = 7,
}

impl Severity {
    /// Get severity name
    pub fn name(&self) -> &'static str {
        match self {
            Severity::Emergency => "EMERG",
            Severity::Alert => "ALERT",
            Severity::Critical => "CRIT",
            Severity::Error => "ERROR",
            Severity::Warning => "WARN",
            Severity::Notice => "NOTICE",
            Severity::Info => "INFO",
            Severity::Debug => "DEBUG",
        }
    }
}

/// Syslog configuration
#[derive(Clone)]
pub struct SyslogConfig {
    /// Remote server IP
    pub server_ip: Ipv4Address,
    /// Remote server port
    pub server_port: u16,
    /// Network device index
    pub device_index: usize,
    /// Hostname to use in messages
    pub hostname: [u8; 32],
    /// Hostname length
    pub hostname_len: usize,
    /// Application name
    pub app_name: [u8; 32],
    /// App name length
    pub app_name_len: usize,
    /// Default facility
    pub facility: Facility,
    /// Minimum severity to log
    pub min_severity: Severity,
    /// Use RFC 5424 format (otherwise RFC 3164)
    pub use_rfc5424: bool,
}

impl Default for SyslogConfig {
    fn default() -> Self {
        let mut hostname = [0u8; 32];
        hostname[..9].copy_from_slice(b"nostalgos");

        let mut app_name = [0u8; 32];
        app_name[..6].copy_from_slice(b"kernel");

        Self {
            server_ip: Ipv4Address::new([0, 0, 0, 0]),
            server_port: SYSLOG_PORT,
            device_index: 0,
            hostname,
            hostname_len: 9,
            app_name,
            app_name_len: 6,
            facility: Facility::Kern,
            min_severity: Severity::Info,
            use_rfc5424: false,
        }
    }
}

/// Global syslog state
static SYSLOG_ENABLED: AtomicBool = AtomicBool::new(false);
static mut SYSLOG_CONFIG: Option<SyslogConfig> = None;
static SYSLOG_LOCK: SpinLock<()> = SpinLock::new(());

/// Statistics
static MESSAGES_SENT: AtomicU32 = AtomicU32::new(0);
static MESSAGES_DROPPED: AtomicU32 = AtomicU32::new(0);
static BYTES_SENT: AtomicU32 = AtomicU32::new(0);

/// Syslog statistics
#[derive(Debug, Clone, Copy, Default)]
pub struct SyslogStats {
    pub messages_sent: u32,
    pub bytes_sent: u32,
    pub errors: u32,
}

/// Calculate syslog priority value
fn calculate_priority(facility: Facility, severity: Severity) -> u8 {
    ((facility as u8) << 3) | (severity as u8)
}

/// Format RFC 3164 (BSD) syslog message
fn format_bsd_message(
    facility: Facility,
    severity: Severity,
    hostname: &[u8],
    app_name: &[u8],
    message: &str,
) -> Vec<u8> {
    let mut buf = Vec::with_capacity(MAX_MESSAGE_SIZE);

    // Priority: <PRI>
    let pri = calculate_priority(facility, severity);
    buf.push(b'<');
    write_u8_decimal(&mut buf, pri);
    buf.push(b'>');

    // Timestamp: Mmm dd hh:mm:ss
    // For simplicity, use a fixed timestamp (in real impl, get from RTC)
    buf.extend_from_slice(b"Jan  1 00:00:00 ");

    // Hostname
    buf.extend_from_slice(hostname);
    buf.push(b' ');

    // Tag (app name)
    buf.extend_from_slice(app_name);
    buf.extend_from_slice(b": ");

    // Message
    let remaining = MAX_MESSAGE_SIZE.saturating_sub(buf.len());
    let msg_bytes = message.as_bytes();
    let msg_len = msg_bytes.len().min(remaining);
    buf.extend_from_slice(&msg_bytes[..msg_len]);

    buf
}

/// Format RFC 5424 syslog message
fn format_rfc5424_message(
    facility: Facility,
    severity: Severity,
    hostname: &[u8],
    app_name: &[u8],
    message: &str,
) -> Vec<u8> {
    let mut buf = Vec::with_capacity(MAX_MESSAGE_SIZE);

    // Priority and version: <PRI>VERSION
    let pri = calculate_priority(facility, severity);
    buf.push(b'<');
    write_u8_decimal(&mut buf, pri);
    buf.extend_from_slice(b">1 ");

    // Timestamp (NILVALUE for now)
    buf.push(b'-');
    buf.push(b' ');

    // Hostname
    buf.extend_from_slice(hostname);
    buf.push(b' ');

    // App-name
    buf.extend_from_slice(app_name);
    buf.push(b' ');

    // Procid (NILVALUE)
    buf.push(b'-');
    buf.push(b' ');

    // Msgid (NILVALUE)
    buf.push(b'-');
    buf.push(b' ');

    // Structured data (NILVALUE)
    buf.push(b'-');
    buf.push(b' ');

    // Message (UTF-8 BOM optional, we skip it)
    let remaining = MAX_MESSAGE_SIZE.saturating_sub(buf.len());
    let msg_bytes = message.as_bytes();
    let msg_len = msg_bytes.len().min(remaining);
    buf.extend_from_slice(&msg_bytes[..msg_len]);

    buf
}

/// Write u8 as decimal string
fn write_u8_decimal(buf: &mut Vec<u8>, val: u8) {
    if val >= 100 {
        buf.push(b'0' + val / 100);
    }
    if val >= 10 {
        buf.push(b'0' + (val / 10) % 10);
    }
    buf.push(b'0' + val % 10);
}

/// Configure syslog client
pub fn configure(config: SyslogConfig) {
    let _guard = SYSLOG_LOCK.lock();
    unsafe {
        SYSLOG_CONFIG = Some(config);
    }
    crate::serial_println!("[SYSLOG] Syslog configured");
}

/// Enable syslog logging
pub fn enable() {
    SYSLOG_ENABLED.store(true, Ordering::SeqCst);
    crate::serial_println!("[SYSLOG] Syslog enabled");
}

/// Disable syslog logging
pub fn disable() {
    SYSLOG_ENABLED.store(false, Ordering::SeqCst);
}

/// Check if syslog is enabled
pub fn is_enabled() -> bool {
    SYSLOG_ENABLED.load(Ordering::SeqCst)
}

/// Send a syslog message
pub fn send(severity: Severity, message: &str) -> Result<(), &'static str> {
    send_with_facility(Facility::Kern, severity, message)
}

/// Send a syslog message with specific facility
pub fn send_with_facility(
    facility: Facility,
    severity: Severity,
    message: &str,
) -> Result<(), &'static str> {
    if !SYSLOG_ENABLED.load(Ordering::SeqCst) {
        return Ok(()); // Silently succeed if disabled
    }

    let _guard = SYSLOG_LOCK.lock();

    let config = unsafe {
        SYSLOG_CONFIG.as_ref().ok_or("Syslog not configured")?
    };

    // Check severity filter
    if severity > config.min_severity {
        return Ok(()); // Below threshold, skip
    }

    // Check for valid server
    if config.server_ip == Ipv4Address::new([0, 0, 0, 0]) {
        MESSAGES_DROPPED.fetch_add(1, Ordering::Relaxed);
        return Err("No syslog server configured");
    }

    // Format message
    let hostname = &config.hostname[..config.hostname_len];
    let app_name = &config.app_name[..config.app_name_len];

    let packet = if config.use_rfc5424 {
        format_rfc5424_message(facility, severity, hostname, app_name, message)
    } else {
        format_bsd_message(facility, severity, hostname, app_name, message)
    };

    // Send via UDP
    let socket = udp::socket_create().ok_or("Failed to create socket")?;
    let result = udp::socket_sendto(
        socket,
        config.device_index,
        config.server_ip,
        config.server_port,
        &packet,
    );
    let _ = udp::socket_close(socket);

    if result.is_ok() {
        MESSAGES_SENT.fetch_add(1, Ordering::Relaxed);
        BYTES_SENT.fetch_add(packet.len() as u32, Ordering::Relaxed);
        Ok(())
    } else {
        MESSAGES_DROPPED.fetch_add(1, Ordering::Relaxed);
        Err("Failed to send syslog message")
    }
}

/// Convenience functions for each severity level
pub fn emergency(message: &str) -> Result<(), &'static str> {
    send(Severity::Emergency, message)
}

pub fn alert(message: &str) -> Result<(), &'static str> {
    send(Severity::Alert, message)
}

pub fn critical(message: &str) -> Result<(), &'static str> {
    send(Severity::Critical, message)
}

pub fn error(message: &str) -> Result<(), &'static str> {
    send(Severity::Error, message)
}

pub fn warning(message: &str) -> Result<(), &'static str> {
    send(Severity::Warning, message)
}

pub fn notice(message: &str) -> Result<(), &'static str> {
    send(Severity::Notice, message)
}

pub fn info(message: &str) -> Result<(), &'static str> {
    send(Severity::Info, message)
}

pub fn debug(message: &str) -> Result<(), &'static str> {
    send(Severity::Debug, message)
}

/// Get syslog statistics
pub fn get_stats() -> SyslogStats {
    SyslogStats {
        messages_sent: MESSAGES_SENT.load(Ordering::Relaxed),
        bytes_sent: BYTES_SENT.load(Ordering::Relaxed),
        errors: MESSAGES_DROPPED.load(Ordering::Relaxed),
    }
}

/// Get configured syslog server
pub fn get_server() -> Option<(Ipv4Address, u16)> {
    let _guard = SYSLOG_LOCK.lock();
    unsafe {
        SYSLOG_CONFIG.as_ref().map(|c| (c.server_ip, c.server_port))
    }
}

/// Set syslog server
pub fn set_server(device_index: usize, server_ip: Ipv4Address, port: u16) {
    let _guard = SYSLOG_LOCK.lock();
    unsafe {
        if let Some(ref mut config) = SYSLOG_CONFIG {
            config.device_index = device_index;
            config.server_ip = server_ip;
            config.server_port = port;
        } else {
            let mut config = SyslogConfig::default();
            config.device_index = device_index;
            config.server_ip = server_ip;
            config.server_port = port;
            SYSLOG_CONFIG = Some(config);
        }
    }
    SYSLOG_ENABLED.store(true, Ordering::SeqCst);
    crate::serial_println!("[SYSLOG] Server configured: {:?}:{}", server_ip, port);
}

/// Initialize syslog module
pub fn init() {
    unsafe {
        SYSLOG_CONFIG = Some(SyslogConfig::default());
    }
    crate::serial_println!("[SYSLOG] Syslog client initialized");
}
