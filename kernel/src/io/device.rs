//! Device Object Implementation
//!
//! Device objects represent instances of devices in the system. Each
//! driver creates one or more device objects to represent the devices
//! it controls.
//!
//! # Device Stack
//! Devices can be stacked (filter drivers attach above/below).
//! IRPs flow from top to bottom of the stack.
//!
//! # Device Types
//! - Physical devices (disk, keyboard, etc.)
//! - Virtual devices (ramdisk, null, etc.)
//! - Filter devices (encryption, compression, etc.)

use core::ptr;
use core::sync::atomic::{AtomicU32, AtomicI32, Ordering};
use crate::ke::{list::ListEntry, SpinLock, KEvent};
use crate::ob::ObjectHeader;

/// Device type codes
pub mod device_type {
    pub const FILE_DEVICE_BEEP: u32 = 0x00000001;
    pub const FILE_DEVICE_CD_ROM: u32 = 0x00000002;
    pub const FILE_DEVICE_CD_ROM_FILE_SYSTEM: u32 = 0x00000003;
    pub const FILE_DEVICE_CONTROLLER: u32 = 0x00000004;
    pub const FILE_DEVICE_DATALINK: u32 = 0x00000005;
    pub const FILE_DEVICE_DFS: u32 = 0x00000006;
    pub const FILE_DEVICE_DISK: u32 = 0x00000007;
    pub const FILE_DEVICE_DISK_FILE_SYSTEM: u32 = 0x00000008;
    pub const FILE_DEVICE_FILE_SYSTEM: u32 = 0x00000009;
    pub const FILE_DEVICE_INPORT_PORT: u32 = 0x0000000A;
    pub const FILE_DEVICE_KEYBOARD: u32 = 0x0000000B;
    pub const FILE_DEVICE_MAILSLOT: u32 = 0x0000000C;
    pub const FILE_DEVICE_MIDI_IN: u32 = 0x0000000D;
    pub const FILE_DEVICE_MIDI_OUT: u32 = 0x0000000E;
    pub const FILE_DEVICE_MOUSE: u32 = 0x0000000F;
    pub const FILE_DEVICE_MULTI_UNC_PROVIDER: u32 = 0x00000010;
    pub const FILE_DEVICE_NAMED_PIPE: u32 = 0x00000011;
    pub const FILE_DEVICE_NETWORK: u32 = 0x00000012;
    pub const FILE_DEVICE_NETWORK_BROWSER: u32 = 0x00000013;
    pub const FILE_DEVICE_NETWORK_FILE_SYSTEM: u32 = 0x00000014;
    pub const FILE_DEVICE_NULL: u32 = 0x00000015;
    pub const FILE_DEVICE_PARALLEL_PORT: u32 = 0x00000016;
    pub const FILE_DEVICE_PHYSICAL_NETCARD: u32 = 0x00000017;
    pub const FILE_DEVICE_PRINTER: u32 = 0x00000018;
    pub const FILE_DEVICE_SCANNER: u32 = 0x00000019;
    pub const FILE_DEVICE_SERIAL_MOUSE_PORT: u32 = 0x0000001A;
    pub const FILE_DEVICE_SERIAL_PORT: u32 = 0x0000001B;
    pub const FILE_DEVICE_SCREEN: u32 = 0x0000001C;
    pub const FILE_DEVICE_SOUND: u32 = 0x0000001D;
    pub const FILE_DEVICE_STREAMS: u32 = 0x0000001E;
    pub const FILE_DEVICE_TAPE: u32 = 0x0000001F;
    pub const FILE_DEVICE_TAPE_FILE_SYSTEM: u32 = 0x00000020;
    pub const FILE_DEVICE_TRANSPORT: u32 = 0x00000021;
    pub const FILE_DEVICE_UNKNOWN: u32 = 0x00000022;
    pub const FILE_DEVICE_VIDEO: u32 = 0x00000023;
    pub const FILE_DEVICE_VIRTUAL_DISK: u32 = 0x00000024;
    pub const FILE_DEVICE_WAVE_IN: u32 = 0x00000025;
    pub const FILE_DEVICE_WAVE_OUT: u32 = 0x00000026;
    pub const FILE_DEVICE_8042_PORT: u32 = 0x00000027;
    pub const FILE_DEVICE_NETWORK_REDIRECTOR: u32 = 0x00000028;
    pub const FILE_DEVICE_BATTERY: u32 = 0x00000029;
    pub const FILE_DEVICE_BUS_EXTENDER: u32 = 0x0000002A;
    pub const FILE_DEVICE_MODEM: u32 = 0x0000002B;
    pub const FILE_DEVICE_VDM: u32 = 0x0000002C;
    pub const FILE_DEVICE_CONSOLE: u32 = 0x00000050;
}

/// Device characteristics
pub mod device_characteristics {
    /// Removable media
    pub const FILE_REMOVABLE_MEDIA: u32 = 0x00000001;
    /// Read-only device
    pub const FILE_READ_ONLY_DEVICE: u32 = 0x00000002;
    /// Floppy diskette
    pub const FILE_FLOPPY_DISKETTE: u32 = 0x00000004;
    /// Write-once media
    pub const FILE_WRITE_ONCE_MEDIA: u32 = 0x00000008;
    /// Remote device
    pub const FILE_REMOTE_DEVICE: u32 = 0x00000010;
    /// Device is mounted
    pub const FILE_DEVICE_IS_MOUNTED: u32 = 0x00000020;
    /// Virtual volume
    pub const FILE_VIRTUAL_VOLUME: u32 = 0x00000040;
    /// Autogenerated device name
    pub const FILE_AUTOGENERATED_DEVICE_NAME: u32 = 0x00000080;
    /// Device is secure open
    pub const FILE_DEVICE_SECURE_OPEN: u32 = 0x00000100;
}

/// Device flags
pub mod device_flags {
    /// Device has been initialized
    pub const DO_BUFFERED_IO: u32 = 0x00000004;
    /// Direct I/O
    pub const DO_DIRECT_IO: u32 = 0x00000010;
    /// Device exclusive
    pub const DO_EXCLUSIVE: u32 = 0x00000008;
    /// Device has a name
    pub const DO_DEVICE_HAS_NAME: u32 = 0x00000040;
    /// Device initializing
    pub const DO_DEVICE_INITIALIZING: u32 = 0x00000080;
    /// Power pagable
    pub const DO_POWER_PAGABLE: u32 = 0x00002000;
    /// Power inrush
    pub const DO_POWER_INRUSH: u32 = 0x00004000;
    /// Low priority filesystem
    pub const DO_LOW_PRIORITY_FILESYSTEM: u32 = 0x00010000;
}

/// Maximum device name length
pub const DEVICE_NAME_LENGTH: usize = 64;

/// Device Object structure
#[repr(C)]
pub struct DeviceObject {
    /// Object header (for object manager integration)
    pub header: ObjectHeader,

    /// Type identifier
    pub type_id: u16,
    /// Size of structure
    pub size: u16,

    /// Reference count
    pub reference_count: AtomicI32,

    /// Owning driver
    pub driver_object: *mut super::driver::DriverObject,

    /// Next device in driver's device list
    pub next_device: *mut DeviceObject,

    /// Device attached to (we sit on top of)
    pub attached_device: *mut DeviceObject,

    /// Current IRP being processed
    pub current_irp: *mut super::irp::Irp,

    /// Device timer
    pub timer: *mut u8,

    /// Device flags
    pub flags: AtomicU32,

    /// Device characteristics
    pub characteristics: u32,

    /// Device type
    pub device_type: u32,

    /// Stack size (number of devices in stack)
    pub stack_size: u8,

    /// Alignment requirement
    pub alignment_requirement: u32,

    /// Device queue for serializing IRPs
    pub device_queue: DeviceQueue,

    /// DPC for device
    pub dpc: *mut crate::ke::KDpc,

    /// Active thread count
    pub active_thread_count: AtomicU32,

    /// Security descriptor
    pub security_descriptor: *mut u8,

    /// Device lock (event for synchronization)
    pub device_lock: KEvent,

    /// Sector size (for disk devices)
    pub sector_size: u16,

    /// Spare fields
    pub spare1: u16,

    /// Device extension (driver-specific data)
    pub device_extension: *mut u8,

    /// Device extension size
    pub device_extension_size: u32,

    /// Device name
    pub device_name: [u8; DEVICE_NAME_LENGTH],

    /// Device name length
    pub device_name_length: u8,
}

// Safety: DeviceObject uses atomic operations and locks
unsafe impl Sync for DeviceObject {}
unsafe impl Send for DeviceObject {}

impl DeviceObject {
    /// Create a new device object
    pub const fn new() -> Self {
        Self {
            header: ObjectHeader::new(),
            type_id: 0x0003, // IO_TYPE_DEVICE
            size: 0,
            reference_count: AtomicI32::new(1),
            driver_object: ptr::null_mut(),
            next_device: ptr::null_mut(),
            attached_device: ptr::null_mut(),
            current_irp: ptr::null_mut(),
            timer: ptr::null_mut(),
            flags: AtomicU32::new(device_flags::DO_DEVICE_INITIALIZING),
            characteristics: 0,
            device_type: device_type::FILE_DEVICE_UNKNOWN,
            stack_size: 1,
            alignment_requirement: 0,
            device_queue: DeviceQueue::new(),
            dpc: ptr::null_mut(),
            active_thread_count: AtomicU32::new(0),
            security_descriptor: ptr::null_mut(),
            device_lock: KEvent::new(),
            sector_size: 0,
            spare1: 0,
            device_extension: ptr::null_mut(),
            device_extension_size: 0,
            device_name: [0; DEVICE_NAME_LENGTH],
            device_name_length: 0,
        }
    }

    /// Initialize a device object
    pub unsafe fn init(
        &mut self,
        driver: *mut super::driver::DriverObject,
        device_type: u32,
        device_name: Option<&[u8]>,
        characteristics: u32,
    ) {
        self.driver_object = driver;
        self.device_type = device_type;
        self.characteristics = characteristics;
        self.stack_size = 1;
        self.reference_count = AtomicI32::new(1);

        // Set name if provided
        if let Some(name) = device_name {
            let len = name.len().min(DEVICE_NAME_LENGTH - 1);
            self.device_name[..len].copy_from_slice(&name[..len]);
            self.device_name[len] = 0;
            self.device_name_length = len as u8;
            self.flags.fetch_or(device_flags::DO_DEVICE_HAS_NAME, Ordering::SeqCst);
        }

        // Initialize the device queue
        self.device_queue.init();

        // Initialize device lock as a synchronization event
        self.device_lock.init(crate::ke::EventType::Synchronization, true);
    }

    /// Get the device name
    pub fn name(&self) -> &[u8] {
        &self.device_name[..self.device_name_length as usize]
    }

    /// Reference the device
    pub fn reference(&self) -> i32 {
        self.reference_count.fetch_add(1, Ordering::SeqCst) + 1
    }

    /// Dereference the device
    ///
    /// # Returns
    /// true if this was the last reference
    pub fn dereference(&self) -> bool {
        self.reference_count.fetch_sub(1, Ordering::SeqCst) == 1
    }

    /// Get reference count
    pub fn ref_count(&self) -> i32 {
        self.reference_count.load(Ordering::SeqCst)
    }

    /// Set a device flag
    pub fn set_flag(&self, flag: u32) {
        self.flags.fetch_or(flag, Ordering::SeqCst);
    }

    /// Clear a device flag
    pub fn clear_flag(&self, flag: u32) {
        self.flags.fetch_and(!flag, Ordering::SeqCst);
    }

    /// Check if a flag is set
    pub fn has_flag(&self, flag: u32) -> bool {
        (self.flags.load(Ordering::SeqCst) & flag) != 0
    }

    /// Clear initialization flag (device is ready)
    pub fn clear_init_flag(&self) {
        self.clear_flag(device_flags::DO_DEVICE_INITIALIZING);
    }

    /// Get the top of the device stack
    pub fn get_attached_device_reference(&self) -> *mut DeviceObject {
        let mut device = self as *const _ as *mut DeviceObject;
        unsafe {
            while !(*device).attached_device.is_null() {
                device = (*device).attached_device;
            }
        }
        device
    }
}

impl Default for DeviceObject {
    fn default() -> Self {
        Self::new()
    }
}

/// Device Queue - for serializing IRP processing
#[repr(C)]
pub struct DeviceQueue {
    /// Queue head
    pub queue_head: ListEntry,
    /// Queue lock
    pub lock: SpinLock<()>,
    /// Queue is busy (processing an IRP)
    pub busy: bool,
}

impl Default for DeviceQueue {
    fn default() -> Self {
        Self::new()
    }
}

impl DeviceQueue {
    pub const fn new() -> Self {
        Self {
            queue_head: ListEntry::new(),
            lock: SpinLock::new(()),
            busy: false,
        }
    }

    /// Initialize the device queue
    pub fn init(&mut self) {
        self.queue_head.init_head();
        self.busy = false;
    }

    /// Insert an entry into the queue
    ///
    /// # Returns
    /// true if entry was queued (device busy), false if device was idle
    pub unsafe fn insert(&mut self, entry: *mut DeviceQueueEntry) -> bool {
        let _guard = self.lock.lock();

        if self.busy {
            // Device is busy, queue the entry
            self.queue_head.insert_tail(&mut (*entry).entry);
            true
        } else {
            // Device is idle, mark as busy
            self.busy = true;
            false
        }
    }

    /// Remove the next entry from the queue
    ///
    /// # Returns
    /// Pointer to next entry, or null if queue empty
    pub unsafe fn remove_head(&mut self) -> *mut DeviceQueueEntry {
        let _guard = self.lock.lock();

        if self.queue_head.is_empty() {
            self.busy = false;
            ptr::null_mut()
        } else {
            let entry = self.queue_head.remove_head();
            crate::containing_record!(entry, DeviceQueueEntry, entry)
        }
    }

    /// Check if device queue is busy
    pub fn is_busy(&self) -> bool {
        self.busy
    }

    /// Set the busy state
    pub fn set_busy(&mut self, busy: bool) {
        self.busy = busy;
    }

    /// Enqueue an IRP for processing
    ///
    /// This is a helper that stores the IRP pointer in a queue entry
    /// For now, we'll store IRPs directly in the list using the IRP's list_entry
    pub unsafe fn enqueue(&mut self, irp: *mut super::irp::Irp) {
        let _guard = self.lock.lock();
        // Use the IRP's list_entry to add to queue
        self.queue_head.insert_tail(&mut (*irp).list_entry);
    }

    /// Dequeue the next IRP
    ///
    /// # Returns
    /// Pointer to next IRP, or None if queue empty
    pub unsafe fn dequeue(&mut self) -> Option<*mut super::irp::Irp> {
        let _guard = self.lock.lock();

        if self.queue_head.is_empty() {
            self.busy = false;
            None
        } else {
            let entry = self.queue_head.remove_head();
            // Calculate offset of list_entry in Irp
            Some(crate::containing_record!(entry, super::irp::Irp, list_entry))
        }
    }
}

/// Device Queue Entry
#[repr(C)]
pub struct DeviceQueueEntry {
    /// List entry
    pub entry: ListEntry,
    /// Sort key (for priority ordering)
    pub sort_key: u32,
    /// Inserted flag
    pub inserted: bool,
}

impl Default for DeviceQueueEntry {
    fn default() -> Self {
        Self::new()
    }
}

impl DeviceQueueEntry {
    pub const fn new() -> Self {
        Self {
            entry: ListEntry::new(),
            sort_key: 0,
            inserted: false,
        }
    }
}

// ============================================================================
// Device Object Pool
// ============================================================================

/// Maximum number of device objects
pub const MAX_DEVICES: usize = 64;

/// Device object pool
static mut DEVICE_POOL: [DeviceObject; MAX_DEVICES] = {
    const INIT: DeviceObject = DeviceObject::new();
    [INIT; MAX_DEVICES]
};

/// Device pool bitmap
static mut DEVICE_POOL_BITMAP: u64 = 0;

/// Device pool lock
static DEVICE_POOL_LOCK: SpinLock<()> = SpinLock::new(());

/// Create a device object
///
/// # Arguments
/// * `driver` - Owning driver object
/// * `device_type` - Type of device
/// * `device_name` - Optional device name
/// * `characteristics` - Device characteristics
///
/// # Returns
/// Pointer to device object, or null on failure
pub unsafe fn io_create_device(
    driver: *mut super::driver::DriverObject,
    device_type: u32,
    device_name: Option<&[u8]>,
    characteristics: u32,
) -> *mut DeviceObject {
    let _guard = DEVICE_POOL_LOCK.lock();

    for i in 0..MAX_DEVICES {
        if DEVICE_POOL_BITMAP & (1 << i) == 0 {
            DEVICE_POOL_BITMAP |= 1 << i;
            let device = &mut DEVICE_POOL[i] as *mut DeviceObject;
            (*device) = DeviceObject::new();
            (*device).init(driver, device_type, device_name, characteristics);

            // Link to driver's device list
            if !driver.is_null() {
                (*device).next_device = (*driver).device_object;
                (*driver).device_object = device;
            }

            return device;
        }
    }

    ptr::null_mut()
}

/// Delete a device object
pub unsafe fn io_delete_device(device: *mut DeviceObject) {
    if device.is_null() {
        return;
    }

    let _guard = DEVICE_POOL_LOCK.lock();

    // Remove from driver's device list
    let driver = (*device).driver_object;
    if !driver.is_null() {
        if (*driver).device_object == device {
            (*driver).device_object = (*device).next_device;
        } else {
            let mut current = (*driver).device_object;
            while !current.is_null() {
                if (*current).next_device == device {
                    (*current).next_device = (*device).next_device;
                    break;
                }
                current = (*current).next_device;
            }
        }
    }

    // Free the device
    let base = DEVICE_POOL.as_ptr() as usize;
    let offset = device as usize - base;
    let index = offset / core::mem::size_of::<DeviceObject>();

    if index < MAX_DEVICES {
        DEVICE_POOL_BITMAP &= !(1 << index);
    }
}

/// Attach a device to another device (for filter drivers)
pub unsafe fn io_attach_device(
    source: *mut DeviceObject,
    target: *mut DeviceObject,
) -> *mut DeviceObject {
    if source.is_null() || target.is_null() {
        return ptr::null_mut();
    }

    // Find top of target stack
    let mut top = target;
    while !(*top).attached_device.is_null() {
        top = (*top).attached_device;
    }

    // Attach source on top
    (*top).attached_device = source;
    (*source).stack_size = (*top).stack_size + 1;

    // Update stack size for all devices below
    let mut current = target;
    while !current.is_null() && current != source {
        (*current).stack_size = (*source).stack_size;
        current = (*current).attached_device;
    }

    top
}

/// Initialize device subsystem
pub unsafe fn init_device_system() {
    crate::serial_println!("[IO] Device subsystem initialized ({} devices available)", MAX_DEVICES);
}

// ============================================================================
// Device Pool Inspection (for debugging)
// ============================================================================

/// Device pool statistics
#[derive(Debug, Clone, Copy)]
pub struct DevicePoolStats {
    /// Total number of devices in pool
    pub total_devices: usize,
    /// Number of allocated devices
    pub allocated_devices: usize,
    /// Number of free devices
    pub free_devices: usize,
}

/// Snapshot of an allocated device
#[derive(Debug, Clone, Copy)]
pub struct DeviceSnapshot {
    /// Device address
    pub address: u64,
    /// Device name
    pub name: [u8; 32],
    /// Name length
    pub name_length: u8,
    /// Device type
    pub device_type: u32,
    /// Device flags
    pub flags: u32,
    /// Stack size
    pub stack_size: u8,
    /// Has attached device
    pub has_attached: bool,
    /// Has driver
    pub has_driver: bool,
    /// Reference count
    pub ref_count: i32,
}

/// Get device pool statistics
pub fn io_get_device_stats() -> DevicePoolStats {
    unsafe {
        let _guard = DEVICE_POOL_LOCK.lock();
        let allocated = DEVICE_POOL_BITMAP.count_ones() as usize;

        DevicePoolStats {
            total_devices: MAX_DEVICES,
            allocated_devices: allocated,
            free_devices: MAX_DEVICES - allocated,
        }
    }
}

/// Get snapshots of allocated devices
pub fn io_get_device_snapshots(max_count: usize) -> ([DeviceSnapshot; 32], usize) {
    let mut snapshots = [DeviceSnapshot {
        address: 0,
        name: [0; 32],
        name_length: 0,
        device_type: 0,
        flags: 0,
        stack_size: 0,
        has_attached: false,
        has_driver: false,
        ref_count: 0,
    }; 32];

    let max_count = max_count.min(32);
    let mut count = 0;

    unsafe {
        let _guard = DEVICE_POOL_LOCK.lock();

        for i in 0..MAX_DEVICES {
            if count >= max_count {
                break;
            }
            if DEVICE_POOL_BITMAP & (1 << i) != 0 {
                let device = &DEVICE_POOL[i];

                let mut name = [0u8; 32];
                let name_len = (device.device_name_length as usize).min(31);
                name[..name_len].copy_from_slice(&device.device_name[..name_len]);

                snapshots[count] = DeviceSnapshot {
                    address: &DEVICE_POOL[i] as *const _ as u64,
                    name,
                    name_length: name_len as u8,
                    device_type: device.device_type,
                    flags: device.flags.load(Ordering::Relaxed),
                    stack_size: device.stack_size,
                    has_attached: !device.attached_device.is_null(),
                    has_driver: !device.driver_object.is_null(),
                    ref_count: device.reference_count.load(Ordering::Relaxed),
                };
                count += 1;
            }
        }
    }

    (snapshots, count)
}

/// Get device type name
pub fn device_type_name(device_type: u32) -> &'static str {
    match device_type {
        device_type::FILE_DEVICE_DISK => "Disk",
        device_type::FILE_DEVICE_DISK_FILE_SYSTEM => "DiskFS",
        device_type::FILE_DEVICE_FILE_SYSTEM => "FileSystem",
        device_type::FILE_DEVICE_KEYBOARD => "Keyboard",
        device_type::FILE_DEVICE_MOUSE => "Mouse",
        device_type::FILE_DEVICE_NAMED_PIPE => "NamedPipe",
        device_type::FILE_DEVICE_NETWORK => "Network",
        device_type::FILE_DEVICE_NULL => "Null",
        device_type::FILE_DEVICE_SERIAL_PORT => "Serial",
        device_type::FILE_DEVICE_CONSOLE => "Console",
        device_type::FILE_DEVICE_VIRTUAL_DISK => "VirtDisk",
        device_type::FILE_DEVICE_UNKNOWN => "Unknown",
        device_type::FILE_DEVICE_CD_ROM => "CDROM",
        device_type::FILE_DEVICE_TAPE => "Tape",
        device_type::FILE_DEVICE_PRINTER => "Printer",
        _ => "Other",
    }
}
